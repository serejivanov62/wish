# Roadmap: WishSpace

Пошаговый план разработки Telegram Mini App "WishSpace" от инициализации проекта до готового к запуску продукта. План исключает этапы тестирования и деплоя.

---

### Этап 0: Настройка проекта и окружения

**Цель:** Создать структуру проекта, настроить окружение и все необходимые конфигурации.

1.  **Инициализация репозитория и структуры проекта:**
    *   Создать корневую директорию `wishspace`.
    *   Внутри создать поддиректории: `backend` для API и `frontend` для React-приложения.
    *   Создать файл `.gitignore` для исключения ненужных файлов (`node_modules`, `__pycache__`, `.env`, и т.д.).

2.  **Настройка Backend (Python + FastAPI):**
    *   В директории `backend` инициализировать виртуальное окружение.
    *   Установить необходимые библиотеки: `fastapi`, `uvicorn`, `sqlalchemy`, `pydantic`, `python-dotenv`.
    *   Создать базовую структуру FastAPI приложения (`main.py`).

3.  **Настройка Frontend (React):**
    *   В директории `frontend` инициализировать React-приложение с помощью `npx create-react-app frontend`.

4.  **Конфигурация окружения:**
    *   Создать файл `.env.example` с перечислением всех переменных: `TELEGRAM_BOT_TOKEN`, `TELEGRAM_APP_URL`, `FIRECRAWL_API_KEY`, `APP_PORT`, `APP_ENV`.
    *   Создать локальный файл `.env` для разработки.

---

### Этап 1: Backend — База данных и аутентификация

**Цель:** Реализовать основу данных и механизм входа пользователя.

1.  **Проектирование и создание базы данных (SQLite):**
    *   В `backend` создать модуль для работы с БД (`database.py`).
    *   Описать все таблицы (`users`, `categories`, `items`, `events`, `event_items`, `friends`, `bookings`) с помощью SQLAlchemy ORM в файле `models.py`.
    *   Настроить создание и подключение к файлу SQLite.

2.  **Реализация аутентификации пользователя:**
    *   Создать Pydantic-схемы для валидации данных (`schemas.py`).
    *   Реализовать API-эндпоинт `/api/auth/telegram`.
    *   Логика: эндпоинт принимает данные от Telegram Mini App (ID, имя, телефон), ищет пользователя в БД, создает нового, если не найден, и возвращает токен сессии (например, JWT).

---

### Этап 2: Backend — Основной функционал (Товары и Категории)

**Цель:** Реализовать главную функцию приложения — добавление и управление товарами.

1.  **Интеграция с Firecrawl API:**
    *   Изучить документацию Firecrawl API.
    *   Создать сервис (`services/firecrawl.py`) для отправки запросов к Firecrawl, который принимает URL и возвращает структурированные данные (название, цена, фото).

2.  **Реализация Telegram-бота для приема ссылок:**
    *   Настроить базового Telegram-бота, который будет принимать сообщения со ссылками.
    *   Реализовать эндпоинт (webhook) для бота, который будет обрабатывать входящие сообщения.

3.  **Логика добавления товара:**
    *   При получении ссылки и комментария от пользователя:
        1.  Вызвать сервис Firecrawl для парсинга.
        2.  Использовать комментарий как название категории (создать, если не существует).
        3.  Сохранить товар в таблицу `items` с привязкой к пользователю и категории.

4.  **API для управления товарами (CRUD):**
    *   `GET /api/items` — получить все товары пользователя (его "избранное").
    *   `POST /api/items/manual` — добавить товар вручную.
    *   `PUT /api/items/{item_id}` — редактировать товар (заметку, категорию и т.д.).
    *   `DELETE /api/items/{item_id}` — удалить товар.

---

### Этап 3: Frontend — Базовый интерфейс

**Цель:** Создать интерфейс для взаимодействия с основным функционалом.

1.  **Настройка Telegram Mini App SDK:**
    *   Подключить скрипт `telegram-web-app.js` в React-приложении.
    *   Реализовать получение данных пользователя при инициализации приложения.

2.  **Реализация аутентификации:**
    *   При запуске приложения отправлять данные пользователя на бэкенд (`/api/auth/telegram`) для получения токена.

3.  **Экран "Избранное":**
    *   Создать главный компонент для отображения списка товаров.
    *   Реализовать запрос к `GET /api/items` для получения и отображения товаров.
    *   Сгруппировать товары по категориям в интерфейсе.

4.  **Интерфейс управления товарами:**
    *   Создать формы и модальные окна для ручного добавления и редактирования товаров.
    *   Реализовать функции удаления.

---

### Этап 4: Backend — События и Социальные функции

**Цель:** Реализовать функционал виш-листов и взаимодействия между пользователями.

1.  **API для Событий (Виш-листов):**
    *   `POST /api/events` — создание нового события (название, дата).
    *   `GET /api/users/{user_id}/events` — получение списка публичных событий пользователя.
    *   `POST /api/events/{event_id}/items` — добавление товаров из "избранного" в событие.

2.  **API для Социального взаимодействия:**
    *   `GET /api/friends`, `POST /api/friends` — управление списком друзей.
    *   `POST /api/items/{item_id}/book` — эндпоинт для бронирования подарка.

3.  **Логика бронирования:**
    *   При запросе на бронирование, создавать запись в таблице `bookings`.
    *   В эндпоинте получения события (`GET /api/events/{event_id}`) добавить логику: если событие запрашивает владелец, не показывать информацию о брони; если друг — показывать, какие товары забронированы.

---

### Этап 5: Frontend — Расширенный интерфейс

**Цель:** Интегрировать события и социальные функции в UI.

1.  **Интерфейс Событий:**
    *   Создать экран для просмотра, создания и управления своими событиями.
    *   Реализовать интерфейс добавления товаров из избранного в событие.

2.  **Публичная страница виш-листа:**
    *   Создать компонент для отображения публичного виш-листа (события) для друзей.
    *   На этой странице разместить кнопки "Забронировать".

3.  **Реализация бронирования:**
    *   При нажатии на кнопку "Забронировать" отправлять запрос на `POST /api/items/{item_id}/book`.
    *   Обновлять UI, чтобы показать, что товар забронирован (например, сделать его неактивным).

4.  **Интерфейс для друзей:**
    *   Создать раздел для поиска и добавления друзей.

---

### Этап 6: Docker-упаковка

**Цель:** Упаковать все части приложения в Docker для удобного запуска.

1.  **Создание `Dockerfile` для Backend:**
    *   На основе образа Python.
    *   Копирование исходного кода, установка зависимостей из `requirements.txt`.
    *   Запуск `uvicorn` в качестве `CMD`.

2.  **Создание `Dockerfile` для Frontend:**
    *   Использовать многоступенчатую сборку (multi-stage build).
    *   **Stage 1:** На основе образа Node.js, установить зависимости (`npm install`) и собрать статические файлы (`npm run build`).
    *   **Stage 2:** На основе легковесного образа `nginx`, скопировать собранные файлы из первого этапа и настроить `nginx` для их раздачи.

3.  **Создание `docker-compose.yml`:**
    *   Описать два сервиса: `backend` и `frontend`.
    *   Настроить проброс портов (например, `8000:8000` для API и `3000:80` для веб-приложения).
    *   Подключить `.env` файл к `backend` сервису.
    *   Настроить volume для персистентного хранения файла базы данных SQLite.
